<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>Data - basis.memory.Data</title>
          <meta name="description" content="Data - basis.memory.Data" />
          <meta name="keywords" content="Data basis.memory.Data" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
      <script type="text/javascript" src="../../lib/modernizr.custom.js"></script><script type="text/javascript" src="../../lib/diagrams.js" id="diagrams-js"></script>
      <script type="text/javascript">
         if(top === self) {
            var url = '../../index.html';
            var hash = 'basis.memory.Data';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <a href="Data$.html" title="Go to companion"><img src="../../lib/class_to_object_big.png" /></a>
        <p id="owner"><a href="../package.html" class="extype" name="basis">basis</a>.<a href="package.html" class="extype" name="basis.memory">memory</a></p>
        <h1><a href="Data$.html" title="Go to companion">Data</a></h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">Data</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>A byte-addressed memory region.</p><h4>Address Space</h4><p><code>Data</code> objects have a 64-bit <i>address space</i> ranging from <code>0</code> until <code>size</code>.
Each <i>address</i> in the space identifies a unique storage location for a
single <code>Byte</code> value. Multi-byte values occupy multiple storage locations and
thus have multiple addressesâ€“one address per byte. The lowest address of a
multi-byte sequence canonically refers to the whole byte sequence.</p><p>N-byte divisible addresses are said to be N-byte <i>aligned</i>. Using aligned
addresses reduces some multi-byte memory accesses to single array operations,
which can improve performance. Alignment sensitive allocators, such as the
default <a href="Data$.html" class="extype" name="basis.memory.Data">Data</a> allocator, try to allocate memory backed by a primitive
array whose element size matches the alignment of the struct values it will
store. This allocation strategy, combined with proper address alignment,
enables an optimal code path when serializaing many values.</p><p>Aligned memory accesses truncate unaligned addresses to their required alignment.</p><h4>Value Types</h4><p><code>Data</code> objects store structured value types. <a href="Struct.html" class="extype" name="basis.memory.Struct">Structs</a> model
value types as transformations between instance types and fixed-length
byte sequences, with a restriction on address alignment.</p><p>Primitive types have dedicated <code>load</code> and <code>store</code> methods, with multi-byte
primitives declaring <i>aligned</i> and <i>unaligned</i> variants. A <code>Data</code> object's
<code>endian</code> property specifies the byte order used to interpret multi-byte values.
</p></div><dl class="attributes block"> <dt>Source</dt><dd><a href="https://github.com/reifyit/basis/tree/master/basis-memory/src/main/scala/basis/memory/Data.scala" target="_blank">Data.scala</a></dd><div class="block">Example:
               <ol><li class="cmt"><p></p><pre>scala&gt; <span class="kw">val</span> data = Data.alloc[<span class="std">Int</span>](<span class="num">1</span>L) <span class="cmt">// allocate data for a single Int value.</span>
data: basis.memory.Data = Data4LE(<span class="num">4</span>) <span class="cmt">// the runtime Data class may vary.</span>

scala&gt; data.storeInt(<span class="num">0</span>L, <span class="num">0</span>xCAFEBABE) <span class="cmt">// store an Int value to address 0.</span>

scala&gt; data.loadInt(<span class="num">0</span>L).toHexString <span class="cmt">// load an Int value from address 0.</span>
res1: <span class="std">String</span> = cafebabe

scala&gt; data.loadByte(<span class="num">0</span>L).toHexString <span class="cmt">// load the low byte of the Int value.</span>
res2: <span class="std">String</span> = ffffffbe <span class="cmt">// the least significant byte comes first in this case.</span>

scala&gt; data.loadShort(<span class="num">2</span>L).toHexString <span class="cmt">// load the high bytes of the Int value.</span>
res3: <span class="std">String</span> = ffffcafe <span class="cmt">// toHexString sign extends the result to an Int.</span>

scala&gt; data.loadShort(<span class="num">1</span>L).toHexString <span class="cmt">// load an unaligned address.</span>
res4: <span class="std">String</span> = ffffbabe <span class="cmt">// the address was truncated, oops.</span>

scala&gt; data.loadUnalignedShort(<span class="num">1</span>L).toHexString <span class="cmt">// load the unaligned middle bytes of the Int value.</span>
res5: <span class="std">String</span> = fffffeba</pre></li></ol>
            </div><dt>Version</dt><dd><p>0.0</p></dd><dt>Since</dt><dd><p>0.0
</p></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div><div class="toggleContainer block diagram-container" id="inheritance-diagram-container">
                <span class="toggle diagram-link">Type Hierarchy</span>
                <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#diagrams" target="_blank" class="diagram-help">Learn more about scaladoc diagrams</a>
                <div class="diagram" id="inheritance-diagram"><svg class="class-diagram" id="graph129" viewBox="0.00 0.00 122.00 120.00" height="120pt" width="122pt" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg"><g transform="scale(1 1) rotate(0) translate(4 116)" class="graph" id="graph1"><polygon points="-4,5 -4,-116 119,-116 119,5 -4,5" stroke="white" fill="white"></polygon><g class="cluster" id="graph2"></g><g class="cluster" id="graph3"></g><!-- node0 --><g class="node this class" id="graph129_0"><a xlink:title="basis.memory.Data (this class)" xlink:href="#inheritance-diagram"><polygon points="89.25,-50 24.75,-50 24.75,-24 89.25,-24 89.25,-50" stroke="#115f3b" fill="#0a955b"></polygon><image xlink:href="../../lib/class_diagram.png" y="-45" x="35" preserveAspectRatio="xMinYMin meet" height="16px" width="16px"></image><text fill="#ffffff" font-size="10.00" font-family="Arial" y="-33" x="57" text-anchor="start">Data</text></a></g><!-- node1 --><g class="node class" id="graph129_1"><a xlink:title="scala.AnyRef"><polygon points="95.25,-112 18.75,-112 18.75,-86 95.25,-86 95.25,-112" stroke="#115f3b" fill="#0a955b"></polygon><image xlink:href="../../lib/class_diagram.png" y="-107" x="29" preserveAspectRatio="xMinYMin meet" height="16px" width="16px"></image><text fill="#ffffff" font-size="10.00" font-family="Arial" y="-95" x="51" text-anchor="start">AnyRef</text></a></g><!-- node1&#45;&gt;node0 --><g class="edge inheritance" id="graph129_1_0"><a xlink:title="Data is a subtype of AnyRef"><path d="M57,-80.6826C57,-70.8961 57,-58.9026 57,-50.1238" stroke="#d4d4d4" fill="none"></path><polygon points="55.2501,-80.8581 57,-85.8581 58.7501,-80.8581 55.2501,-80.8581" stroke="#d4d4d4" fill="none"></polygon></a></g></g></svg></div>
              </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                <li class="group out"><span>Grouped</span></li>
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="basis.memory.Data"><span>Data</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="basis.memory.Data#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&lt;init&gt;():basis.memory.Data"></a>
      <a id="&lt;init&gt;:Data"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">Data</span><span class="params">()</span>
      </span>
      </h4>
      
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Abstract Value Members</h3>
              <ol><li name="basis.memory.Data#copy" visbl="pub" data-isabs="true" fullComment="yes" group="Bulk">
      <a id="copy(size:Long):basis.memory.Data"></a>
      <a id="copy(Long):Data"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">copy</span><span class="params">(<span name="size">size: <span class="extype" name="scala.Long">Long</span> = <span class="symbol"><span class="name"><a href="#size:Long">this.size</a></span></span></span>)</span><span class="result">: <a href="" class="extype" name="basis.memory.Data">Data</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a resized copy of this data.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a resized copy of this data.
</p></div><dl class="paramcmts block"><dt class="param">size</dt><dd class="cmt"><p>the number of bytes to copy.</p></dd><dt>returns</dt><dd class="cmt"><p>the copied data.</p></dd></dl></div>
    </li><li name="basis.memory.Data#endian" visbl="pub" data-isabs="true" fullComment="no" group="General">
      <a id="endian:basis.memory.Endianness"></a>
      <a id="endian:Endianness"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">endian</span><span class="result">: <a href="Endianness.html" class="extype" name="basis.memory.Endianness">Endianness</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the internal byte order.</p>
    </li><li name="basis.memory.Data#loadByte" visbl="pub" data-isabs="true" fullComment="yes" group="Aligned">
      <a id="loadByte(address:Long):Byte"></a>
      <a id="loadByte(Long):Byte"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">loadByte</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Byte">Byte</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads a single byte.</p><div class="fullcomment"><div class="comment cmt"><p>Loads a single byte.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the address to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded <code>Byte</code> value.</p></dd></dl></div>
    </li><li name="basis.memory.Data#size" visbl="pub" data-isabs="true" fullComment="no" group="General">
      <a id="size:Long"></a>
      <a id="size:Long"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">size</span><span class="result">: <span class="extype" name="scala.Long">Long</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the size in bytes of the address space.</p>
    </li><li name="basis.memory.Data#storeByte" visbl="pub" data-isabs="true" fullComment="yes" group="Aligned">
      <a id="storeByte(address:Long,value:Byte):Unit"></a>
      <a id="storeByte(Long,Byte):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">storeByte</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Byte">Byte</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores a single byte.</p><div class="fullcomment"><div class="comment cmt"><p>Stores a single byte.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the storage address.</p></dd><dt class="param">value</dt><dd class="cmt"><p>the <code>Byte</code> value to store.</p></dd></dl></div>
    </li><li name="basis.memory.Data#unit" visbl="pub" data-isabs="true" fullComment="no" group="General">
      <a id="unit:Int"></a>
      <a id="unit:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unit</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the internal word size.</p>
    </li></ol>
            </div>

        <div id="values" class="values members">
              <h3>Concrete Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="basis.memory.Data#clear" visbl="pub" data-isabs="false" fullComment="yes" group="Bulk">
      <a id="clear(fromAddress:Long,untilAddress:Long):Unit"></a>
      <a id="clear(Long,Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clear</span><span class="params">(<span name="fromAddress">fromAddress: <span class="extype" name="scala.Long">Long</span></span>, <span name="untilAddress">untilAddress: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Zeros a range of addresses.</p><div class="fullcomment"><div class="comment cmt"><p>Zeros a range of addresses.
</p></div><dl class="paramcmts block"><dt class="param">fromAddress</dt><dd class="cmt"><p>the lower bound of the address range.</p></dd><dt class="param">untilAddress</dt><dd class="cmt"><p>the excluded upper bound of the address range.</p></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="basis.memory.Data#copyToArray" visbl="pub" data-isabs="false" fullComment="yes" group="Aggregate">
      <a id="copyToArray[T](address:Long,array:Array[T],start:Int,count:Int)(implicitT:basis.memory.Struct[T]):Unit"></a>
      <a id="copyToArray[T](Long,Array[T],Int,Int)(Struct[T]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">copyToArray</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="array">array: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="basis.memory.Data.copyToArray.T">T</span>]</span>, <span name="start">start: <span class="extype" name="scala.Int">Int</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="T">T: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.copyToArray.T">T</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Copies a sequence of loaded struct values to an array slice.</p><div class="fullcomment"><div class="comment cmt"><p>Copies a sequence of loaded struct values to an array slice.
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the instance type to load.</p></dd><dt class="param">address</dt><dd class="cmt"><p>the aligned address to load.</p></dd><dt class="param">array</dt><dd class="cmt"><p>the array to copy to.</p></dd><dt class="param">start</dt><dd class="cmt"><p>the offset to copy to in the array.</p></dd><dt class="param">count</dt><dd class="cmt"><p>the number of values to copy.</p></dd><dt class="param">T</dt><dd class="cmt"><p>the implicit struct type to load.</p></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="basis.memory.Data#load" visbl="pub" data-isabs="false" fullComment="yes" group="Compound">
      <a id="load[T](address:Long)(implicitT:basis.memory.Struct[T]):T"></a>
      <a id="load[T](Long)(Struct[T]):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">load</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="T">T: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.load.T">T</span>]</span>)</span><span class="result">: <span class="extype" name="basis.memory.Data.load.T">T</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads an instance from a struct value.</p><div class="fullcomment"><div class="comment cmt"><p>Loads an instance from a struct value.
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the instance type to load.</p></dd><dt class="param">address</dt><dd class="cmt"><p>the aligned address to load.</p></dd><dt class="param">T</dt><dd class="cmt"><p>the implicit struct type to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded instance.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@macroImpl</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="basis.memory.Data#load2" visbl="pub" data-isabs="false" fullComment="yes" group="Compound">
      <a id="load2[T1,T2,R](address:Long)(f:(T1,T2)=&gt;R)(implicitT1:basis.memory.Struct[T1],implicitT2:basis.memory.Struct[T2]):R"></a>
      <a id="load2[T1,T2,R](Long)((T1,T2)â‡’R)(Struct[T1],Struct[T2]):R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">load2</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="R">R</span>]</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="basis.memory.Data.load2.T1">T1</span>, <span class="extype" name="basis.memory.Data.load2.T2">T2</span>) â‡’ <span class="extype" name="basis.memory.Data.load2.R">R</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="T1">T1: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.load2.T1">T1</span>]</span>, <span name="T2">T2: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.load2.T2">T2</span>]</span>)</span><span class="result">: <span class="extype" name="basis.memory.Data.load2.R">R</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads and unpacks a struct as two values.</p><div class="fullcomment"><div class="comment cmt"><p>Loads and unpacks a struct as two values.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@macroImpl</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="basis.memory.Data#load3" visbl="pub" data-isabs="false" fullComment="yes" group="Compound">
      <a id="load3[T1,T2,T3,R](address:Long)(f:(T1,T2,T3)=&gt;R)(implicitT1:basis.memory.Struct[T1],implicitT2:basis.memory.Struct[T2],implicitT3:basis.memory.Struct[T3]):R"></a>
      <a id="load3[T1,T2,T3,R](Long)((T1,T2,T3)â‡’R)(Struct[T1],Struct[T2],Struct[T3]):R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">load3</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>, <span name="R">R</span>]</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="basis.memory.Data.load3.T1">T1</span>, <span class="extype" name="basis.memory.Data.load3.T2">T2</span>, <span class="extype" name="basis.memory.Data.load3.T3">T3</span>) â‡’ <span class="extype" name="basis.memory.Data.load3.R">R</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="T1">T1: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.load3.T1">T1</span>]</span>, <span name="T2">T2: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.load3.T2">T2</span>]</span>, <span name="T3">T3: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.load3.T3">T3</span>]</span>)</span><span class="result">: <span class="extype" name="basis.memory.Data.load3.R">R</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads and unpacks a struct as three values.</p><div class="fullcomment"><div class="comment cmt"><p>Loads and unpacks a struct as three values.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@macroImpl</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="basis.memory.Data#load4" visbl="pub" data-isabs="false" fullComment="yes" group="Compound">
      <a id="load4[T1,T2,T3,T4,R](address:Long)(f:(T1,T2,T3,T4)=&gt;R)(implicitT1:basis.memory.Struct[T1],implicitT2:basis.memory.Struct[T2],implicitT3:basis.memory.Struct[T3],implicitT4:basis.memory.Struct[T4]):R"></a>
      <a id="load4[T1,T2,T3,T4,R](Long)((T1,T2,T3,T4)â‡’R)(Struct[T1],Struct[T2],Struct[T3],Struct[T4]):R"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">load4</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>, <span name="T4">T4</span>, <span name="R">R</span>]</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="basis.memory.Data.load4.T1">T1</span>, <span class="extype" name="basis.memory.Data.load4.T2">T2</span>, <span class="extype" name="basis.memory.Data.load4.T3">T3</span>, <span class="extype" name="basis.memory.Data.load4.T4">T4</span>) â‡’ <span class="extype" name="basis.memory.Data.load4.R">R</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="T1">T1: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.load4.T1">T1</span>]</span>, <span name="T2">T2: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.load4.T2">T2</span>]</span>, <span name="T3">T3: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.load4.T3">T3</span>]</span>, <span name="T4">T4: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.load4.T4">T4</span>]</span>)</span><span class="result">: <span class="extype" name="basis.memory.Data.load4.R">R</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads and unpacks a struct as four values.</p><div class="fullcomment"><div class="comment cmt"><p>Loads and unpacks a struct as four values.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@macroImpl</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="basis.memory.Data#loadArray" visbl="pub" data-isabs="false" fullComment="yes" group="Aggregate">
      <a id="loadArray[T](address:Long,count:Int)(implicitT:basis.memory.Struct[T]):Array[T]"></a>
      <a id="loadArray[T](Long,Int)(Struct[T]):Array[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">loadArray</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="T">T: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.loadArray.T">T</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="basis.memory.Data.loadArray.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads a sequence of struct values into a new array.</p><div class="fullcomment"><div class="comment cmt"><p>Loads a sequence of struct values into a new array.
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the instance type to load.</p></dd><dt class="param">address</dt><dd class="cmt"><p>the aligned address to load.</p></dd><dt class="param">count</dt><dd class="cmt"><p>the number of values to load.</p></dd><dt class="param">T</dt><dd class="cmt"><p>the implicit struct type to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded array of instance values.</p></dd></dl></div>
    </li><li name="basis.memory.Data#loadDouble" visbl="pub" data-isabs="false" fullComment="yes" group="Aligned">
      <a id="loadDouble(address:Long):Double"></a>
      <a id="loadDouble(Long):Double"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">loadDouble</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Double">Double</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads an 8-byte <code>endian</code> ordered word as a native-endian <code>Double</code> value.</p><div class="fullcomment"><div class="comment cmt"><p>Loads an 8-byte <code>endian</code> ordered word as a native-endian <code>Double</code> value.
Truncates <code>address</code> to 8-byte alignment.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the 8-byte aligned address to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded <code>Double</code> value.</p></dd></dl></div>
    </li><li name="basis.memory.Data#loadFloat" visbl="pub" data-isabs="false" fullComment="yes" group="Aligned">
      <a id="loadFloat(address:Long):Float"></a>
      <a id="loadFloat(Long):Float"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">loadFloat</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Float">Float</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads a 4-byte <code>endian</code> ordered word as a native-endian <code>Float</code> value.</p><div class="fullcomment"><div class="comment cmt"><p>Loads a 4-byte <code>endian</code> ordered word as a native-endian <code>Float</code> value.
Truncates <code>address</code> to 4-byte alignment.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the 4-byte aligned address to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded <code>Float</code> value.</p></dd></dl></div>
    </li><li name="basis.memory.Data#loadInt" visbl="pub" data-isabs="false" fullComment="yes" group="Aligned">
      <a id="loadInt(address:Long):Int"></a>
      <a id="loadInt(Long):Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">loadInt</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads a 4-byte <code>endian</code> ordered word as a native-endian <code>Int</code> value.</p><div class="fullcomment"><div class="comment cmt"><p>Loads a 4-byte <code>endian</code> ordered word as a native-endian <code>Int</code> value.
Truncates <code>address</code> to 4-byte alignment.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the 4-byte aligned address to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded <code>Int</code> value.</p></dd></dl></div>
    </li><li name="basis.memory.Data#loadLong" visbl="pub" data-isabs="false" fullComment="yes" group="Aligned">
      <a id="loadLong(address:Long):Long"></a>
      <a id="loadLong(Long):Long"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">loadLong</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Long">Long</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads an 8-byte <code>endian</code> ordered word as a native-endian <code>Long</code> value.</p><div class="fullcomment"><div class="comment cmt"><p>Loads an 8-byte <code>endian</code> ordered word as a native-endian <code>Long</code> value.
Truncates <code>address</code> to 8-byte alignment.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the 8-byte aligned address to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded <code>Long</code> value.</p></dd></dl></div>
    </li><li name="basis.memory.Data#loadShort" visbl="pub" data-isabs="false" fullComment="yes" group="Aligned">
      <a id="loadShort(address:Long):Short"></a>
      <a id="loadShort(Long):Short"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">loadShort</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Short">Short</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads a 2-byte <code>endian</code> ordered word as a native-endian <code>Short</code> value.</p><div class="fullcomment"><div class="comment cmt"><p>Loads a 2-byte <code>endian</code> ordered word as a native-endian <code>Short</code> value.
Truncates <code>address</code> to 2-byte alignment.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the 2-byte aligned address to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded <code>Short</code> value.</p></dd></dl></div>
    </li><li name="basis.memory.Data#loadUnalignedDouble" visbl="pub" data-isabs="false" fullComment="yes" group="Unaligned">
      <a id="loadUnalignedDouble(address:Long):Double"></a>
      <a id="loadUnalignedDouble(Long):Double"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">loadUnalignedDouble</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Double">Double</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads an 8-byte <code>endian</code> ordered word as a native-endian <code>Double</code> value.</p><div class="fullcomment"><div class="comment cmt"><p>Loads an 8-byte <code>endian</code> ordered word as a native-endian <code>Double</code> value.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the unaligned address to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded <code>Double</code> value.</p></dd></dl></div>
    </li><li name="basis.memory.Data#loadUnalignedFloat" visbl="pub" data-isabs="false" fullComment="yes" group="Unaligned">
      <a id="loadUnalignedFloat(address:Long):Float"></a>
      <a id="loadUnalignedFloat(Long):Float"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">loadUnalignedFloat</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Float">Float</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads a 4-byte <code>endian</code> ordered word as a native-endian <code>Float</code> value.</p><div class="fullcomment"><div class="comment cmt"><p>Loads a 4-byte <code>endian</code> ordered word as a native-endian <code>Float</code> value.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the unaligned address to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded <code>Float</code> value.</p></dd></dl></div>
    </li><li name="basis.memory.Data#loadUnalignedInt" visbl="pub" data-isabs="false" fullComment="yes" group="Unaligned">
      <a id="loadUnalignedInt(address:Long):Int"></a>
      <a id="loadUnalignedInt(Long):Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">loadUnalignedInt</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads a 4-byte <code>endian</code> ordered word as a native-endian <code>Int</code> value.</p><div class="fullcomment"><div class="comment cmt"><p>Loads a 4-byte <code>endian</code> ordered word as a native-endian <code>Int</code> value.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the unaligned address to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded <code>Int</code> value.</p></dd></dl></div>
    </li><li name="basis.memory.Data#loadUnalignedLong" visbl="pub" data-isabs="false" fullComment="yes" group="Unaligned">
      <a id="loadUnalignedLong(address:Long):Long"></a>
      <a id="loadUnalignedLong(Long):Long"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">loadUnalignedLong</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Long">Long</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads an 8-byte <code>endian</code> ordered word as a native-endian <code>Long</code> value.</p><div class="fullcomment"><div class="comment cmt"><p>Loads an 8-byte <code>endian</code> ordered word as a native-endian <code>Long</code> value.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the unaligned address to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded <code>Long</code> value.</p></dd></dl></div>
    </li><li name="basis.memory.Data#loadUnalignedShort" visbl="pub" data-isabs="false" fullComment="yes" group="Unaligned">
      <a id="loadUnalignedShort(address:Long):Short"></a>
      <a id="loadUnalignedShort(Long):Short"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">loadUnalignedShort</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Short">Short</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads a 2-byte <code>endian</code> ordered word as a native-endian <code>Short</code> value.</p><div class="fullcomment"><div class="comment cmt"><p>Loads a 2-byte <code>endian</code> ordered word as a native-endian <code>Short</code> value.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the unaligned address to load.</p></dd><dt>returns</dt><dd class="cmt"><p>the loaded <code>Short</code> value.</p></dd></dl></div>
    </li><li name="basis.memory.Data#move" visbl="pub" data-isabs="false" fullComment="yes" group="Bulk">
      <a id="move(fromAddress:Long,toAddress:Long,size:Long):Unit"></a>
      <a id="move(Long,Long,Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">move</span><span class="params">(<span name="fromAddress">fromAddress: <span class="extype" name="scala.Long">Long</span></span>, <span name="toAddress">toAddress: <span class="extype" name="scala.Long">Long</span></span>, <span name="size">size: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Moves a byte range to a new, potentially overlapping address.</p><div class="fullcomment"><div class="comment cmt"><p>Moves a byte range to a new, potentially overlapping address.
</p></div><dl class="paramcmts block"><dt class="param">fromAddress</dt><dd class="cmt"><p>the address to copy from.</p></dd><dt class="param">toAddress</dt><dd class="cmt"><p>the address to copy to.</p></dd><dt class="param">size</dt><dd class="cmt"><p>the number of bytes to copy.</p></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="basis.memory.Data#store" visbl="pub" data-isabs="false" fullComment="yes" group="Compound">
      <a id="store[T](address:Long,value:T)(implicitT:basis.memory.Struct[T]):Unit"></a>
      <a id="store[T](Long,T)(Struct[T]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">store</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="basis.memory.Data.store.T">T</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="T">T: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.store.T">T</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores an instance as a struct value.</p><div class="fullcomment"><div class="comment cmt"><p>Stores an instance as a struct value.
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the instance type to store.</p></dd><dt class="param">address</dt><dd class="cmt"><p>the aligned storage address.</p></dd><dt class="param">value</dt><dd class="cmt"><p>the instance to store.</p></dd><dt class="param">T</dt><dd class="cmt"><p>the implicit struct type to store.</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@macroImpl</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="basis.memory.Data#store2" visbl="pub" data-isabs="false" fullComment="yes" group="Compound">
      <a id="store2[T1,T2](address:Long)(value1:T1,value2:T2)(implicitT1:basis.memory.Struct[T1],implicitT2:basis.memory.Struct[T2]):Unit"></a>
      <a id="store2[T1,T2](Long)(T1,T2)(Struct[T1],Struct[T2]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">store2</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>]</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span name="value1">value1: <span class="extype" name="basis.memory.Data.store2.T1">T1</span></span>, <span name="value2">value2: <span class="extype" name="basis.memory.Data.store2.T2">T2</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="T1">T1: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.store2.T1">T1</span>]</span>, <span name="T2">T2: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.store2.T2">T2</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Packs and stores two values as a struct.</p><div class="fullcomment"><div class="comment cmt"><p>Packs and stores two values as a struct.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@macroImpl</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="basis.memory.Data#store3" visbl="pub" data-isabs="false" fullComment="yes" group="Compound">
      <a id="store3[T1,T2,T3](address:Long)(value1:T1,value2:T2,value3:T3)(implicitT1:basis.memory.Struct[T1],implicitT2:basis.memory.Struct[T2],implicitT3:basis.memory.Struct[T3]):Unit"></a>
      <a id="store3[T1,T2,T3](Long)(T1,T2,T3)(Struct[T1],Struct[T2],Struct[T3]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">store3</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>]</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span name="value1">value1: <span class="extype" name="basis.memory.Data.store3.T1">T1</span></span>, <span name="value2">value2: <span class="extype" name="basis.memory.Data.store3.T2">T2</span></span>, <span name="value3">value3: <span class="extype" name="basis.memory.Data.store3.T3">T3</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="T1">T1: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.store3.T1">T1</span>]</span>, <span name="T2">T2: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.store3.T2">T2</span>]</span>, <span name="T3">T3: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.store3.T3">T3</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Packs and stores three values as a struct.</p><div class="fullcomment"><div class="comment cmt"><p>Packs and stores three values as a struct.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@macroImpl</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="basis.memory.Data#store4" visbl="pub" data-isabs="false" fullComment="yes" group="Compound">
      <a id="store4[T1,T2,T3,T4](address:Long)(value1:T1,value2:T2,value3:T3,value4:T4)(implicitT1:basis.memory.Struct[T1],implicitT2:basis.memory.Struct[T2],implicitT3:basis.memory.Struct[T3],implicitT4:basis.memory.Struct[T4]):Unit"></a>
      <a id="store4[T1,T2,T3,T4](Long)(T1,T2,T3,T4)(Struct[T1],Struct[T2],Struct[T3],Struct[T4]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">store4</span><span class="tparams">[<span name="T1">T1</span>, <span name="T2">T2</span>, <span name="T3">T3</span>, <span name="T4">T4</span>]</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span name="value1">value1: <span class="extype" name="basis.memory.Data.store4.T1">T1</span></span>, <span name="value2">value2: <span class="extype" name="basis.memory.Data.store4.T2">T2</span></span>, <span name="value3">value3: <span class="extype" name="basis.memory.Data.store4.T3">T3</span></span>, <span name="value4">value4: <span class="extype" name="basis.memory.Data.store4.T4">T4</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="T1">T1: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.store4.T1">T1</span>]</span>, <span name="T2">T2: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.store4.T2">T2</span>]</span>, <span name="T3">T3: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.store4.T3">T3</span>]</span>, <span name="T4">T4: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.store4.T4">T4</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Packs and stores four values as a struct.</p><div class="fullcomment"><div class="comment cmt"><p>Packs and stores four values as a struct.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@macroImpl</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="basis.memory.Data#storeArray" visbl="pub" data-isabs="false" fullComment="yes" group="Aggregate">
      <a id="storeArray[T](address:Long,array:Array[T],start:Int,count:Int)(implicitT:basis.memory.Struct[T]):Unit"></a>
      <a id="storeArray[T](Long,Array[T],Int,Int)(Struct[T]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">storeArray</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="array">array: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="basis.memory.Data.storeArray.T">T</span>]</span>, <span name="start">start: <span class="extype" name="scala.Int">Int</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="T">T: <a href="Struct.html" class="extype" name="basis.memory.Struct">Struct</a>[<span class="extype" name="basis.memory.Data.storeArray.T">T</span>]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores an array slice as a sequence of struct values.</p><div class="fullcomment"><div class="comment cmt"><p>Stores an array slice as a sequence of struct values.
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>the instance type to store.</p></dd><dt class="param">address</dt><dd class="cmt"><p>the aligned storage address.</p></dd><dt class="param">array</dt><dd class="cmt"><p>the array to store from.</p></dd><dt class="param">start</dt><dd class="cmt"><p>the offset to store from in the array.</p></dd><dt class="param">count</dt><dd class="cmt"><p>the number of values to store.</p></dd><dt class="param">T</dt><dd class="cmt"><p>the implicit struct type to store.</p></dd></dl></div>
    </li><li name="basis.memory.Data#storeDouble" visbl="pub" data-isabs="false" fullComment="yes" group="Aligned">
      <a id="storeDouble(address:Long,value:Double):Unit"></a>
      <a id="storeDouble(Long,Double):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">storeDouble</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores a native-endian <code>Double</code> value as an 8-byte <code>endian</code> ordered word.</p><div class="fullcomment"><div class="comment cmt"><p>Stores a native-endian <code>Double</code> value as an 8-byte <code>endian</code> ordered word.
Truncates <code>address</code> to 8-byte alignment.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the 8-byte aligned storage address.</p></dd><dt class="param">value</dt><dd class="cmt"><p>the <code>Double</code> value to store.</p></dd></dl></div>
    </li><li name="basis.memory.Data#storeFloat" visbl="pub" data-isabs="false" fullComment="yes" group="Aligned">
      <a id="storeFloat(address:Long,value:Float):Unit"></a>
      <a id="storeFloat(Long,Float):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">storeFloat</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores a native-endian <code>Float</code> value as a 4-byte <code>endian</code> ordered word.</p><div class="fullcomment"><div class="comment cmt"><p>Stores a native-endian <code>Float</code> value as a 4-byte <code>endian</code> ordered word.
Truncates <code>address</code> to 4-byte alignment.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the 4-byte aligned storage address.</p></dd><dt class="param">value</dt><dd class="cmt"><p>the <code>Float</code> value to store.</p></dd></dl></div>
    </li><li name="basis.memory.Data#storeInt" visbl="pub" data-isabs="false" fullComment="yes" group="Aligned">
      <a id="storeInt(address:Long,value:Int):Unit"></a>
      <a id="storeInt(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">storeInt</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores a native-endian <code>Int</code> value as a 4-byte <code>endian</code> ordered word.</p><div class="fullcomment"><div class="comment cmt"><p>Stores a native-endian <code>Int</code> value as a 4-byte <code>endian</code> ordered word.
Truncates <code>address</code> to 4-byte alignment.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the 4-byte aligned storage address.</p></dd><dt class="param">value</dt><dd class="cmt"><p>the <code>Int</code> value to store.</p></dd></dl></div>
    </li><li name="basis.memory.Data#storeLong" visbl="pub" data-isabs="false" fullComment="yes" group="Aligned">
      <a id="storeLong(address:Long,value:Long):Unit"></a>
      <a id="storeLong(Long,Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">storeLong</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Store a native-endian <code>Long</code> value as an 8-byte <code>endian</code> ordered word.</p><div class="fullcomment"><div class="comment cmt"><p>Store a native-endian <code>Long</code> value as an 8-byte <code>endian</code> ordered word.
Truncates <code>address</code> to 8-byte alignment.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the 8-byte aligned storage address.</p></dd><dt class="param">value</dt><dd class="cmt"><p>the <code>Long</code> value to store.</p></dd></dl></div>
    </li><li name="basis.memory.Data#storeShort" visbl="pub" data-isabs="false" fullComment="yes" group="Aligned">
      <a id="storeShort(address:Long,value:Short):Unit"></a>
      <a id="storeShort(Long,Short):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">storeShort</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Short">Short</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores a native-endian <code>Short</code> value as a 2-byte <code>endian</code> ordered word.</p><div class="fullcomment"><div class="comment cmt"><p>Stores a native-endian <code>Short</code> value as a 2-byte <code>endian</code> ordered word.
Truncates <code>address</code> to 2-byte alignment.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the 2-byte aligned storage address.</p></dd><dt class="param">value</dt><dd class="cmt"><p>the <code>Short</code> value to store.</p></dd></dl></div>
    </li><li name="basis.memory.Data#storeUnalignedDouble" visbl="pub" data-isabs="false" fullComment="yes" group="Unaligned">
      <a id="storeUnalignedDouble(address:Long,value:Double):Unit"></a>
      <a id="storeUnalignedDouble(Long,Double):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">storeUnalignedDouble</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores a native-endian <code>Double</code> value as an 8-byte <code>endian</code> ordered word.</p><div class="fullcomment"><div class="comment cmt"><p>Stores a native-endian <code>Double</code> value as an 8-byte <code>endian</code> ordered word.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the unaligned storage address.</p></dd><dt class="param">value</dt><dd class="cmt"><p>the <code>Double</code> value to store.</p></dd></dl></div>
    </li><li name="basis.memory.Data#storeUnalignedFloat" visbl="pub" data-isabs="false" fullComment="yes" group="Unaligned">
      <a id="storeUnalignedFloat(address:Long,value:Float):Unit"></a>
      <a id="storeUnalignedFloat(Long,Float):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">storeUnalignedFloat</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Float">Float</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores a native-endian <code>Float</code> value as a 4-byte <code>endian</code> ordered word.</p><div class="fullcomment"><div class="comment cmt"><p>Stores a native-endian <code>Float</code> value as a 4-byte <code>endian</code> ordered word.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the unaligned storage address.</p></dd><dt class="param">value</dt><dd class="cmt"><p>the <code>Float</code> value to store.</p></dd></dl></div>
    </li><li name="basis.memory.Data#storeUnalignedInt" visbl="pub" data-isabs="false" fullComment="yes" group="Unaligned">
      <a id="storeUnalignedInt(address:Long,value:Int):Unit"></a>
      <a id="storeUnalignedInt(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">storeUnalignedInt</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores a native-endian <code>Int</code> value as a 4-byte <code>endian</code> ordered word.</p><div class="fullcomment"><div class="comment cmt"><p>Stores a native-endian <code>Int</code> value as a 4-byte <code>endian</code> ordered word.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the unaligned storage address.</p></dd><dt class="param">value</dt><dd class="cmt"><p>the <code>Int</code> value to store.</p></dd></dl></div>
    </li><li name="basis.memory.Data#storeUnalignedLong" visbl="pub" data-isabs="false" fullComment="yes" group="Unaligned">
      <a id="storeUnalignedLong(address:Long,value:Long):Unit"></a>
      <a id="storeUnalignedLong(Long,Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">storeUnalignedLong</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores a native-endian <code>Long</code> value as an 8-byte <code>endian</code> ordered word.</p><div class="fullcomment"><div class="comment cmt"><p>Stores a native-endian <code>Long</code> value as an 8-byte <code>endian</code> ordered word.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the unaligned storage address.</p></dd><dt class="param">value</dt><dd class="cmt"><p>the <code>Long</code> value to store.</p></dd></dl></div>
    </li><li name="basis.memory.Data#storeUnalignedShort" visbl="pub" data-isabs="false" fullComment="yes" group="Unaligned">
      <a id="storeUnalignedShort(address:Long,value:Short):Unit"></a>
      <a id="storeUnalignedShort(Long,Short):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">storeUnalignedShort</span><span class="params">(<span name="address">address: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Short">Short</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores a native-endian <code>Short</code> value as a 2-byte <code>endian</code> ordered word.</p><div class="fullcomment"><div class="comment cmt"><p>Stores a native-endian <code>Short</code> value as a 2-byte <code>endian</code> ordered word.
</p></div><dl class="paramcmts block"><dt class="param">address</dt><dd class="cmt"><p>the unaligned storage address.</p></dd><dt class="param">value</dt><dd class="cmt"><p>the <code>Short</code> value to store.</p></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](â‡’T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: â‡’ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="General">
              <h3>General properties</h3>
              
            </div><div class="group" name="Aligned">
              <h3>Loading and storing aligned primitive values</h3>
              
            </div><div class="group" name="Unaligned">
              <h3>Loading and storing unaligned primitive values</h3>
              
            </div><div class="group" name="Compound">
              <h3>Loading and storing compound values</h3>
              
            </div><div class="group" name="Aggregate">
              <h3>Loading and storing arrays of values</h3>
              
            </div><div class="group" name="Bulk">
              <h3>Bulk transfer operations</h3>
              
            </div><div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>